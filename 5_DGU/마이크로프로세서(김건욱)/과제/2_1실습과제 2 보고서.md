<aside> ğŸ’¡ ì „ì—­ë³€ìˆ˜ë¡œ ì²˜ë¦¬í•˜ëŠ”ê²Œ ê°€ì¥ ì‰¬ìš¸ ê²ƒ ê°™ì•„ì„œ ê·¸ëƒ¥ ì¼ìŠµë‹ˆë‹¤.

</aside>

# ê³¼ì œ ë‚´ìš©

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6617195d-3c86-450f-920c-3551e4bc12a3/ff051e52-82ce-4e91-b0bb-d9f9d4e425aa/Untitled.png)

# ì‹œì—° ì˜ìƒ

[https://youtube.com/shorts/P67D3v44md4?si=lvZm32YMj3iocryA](https://youtube.com/shorts/P67D3v44md4?si=lvZm32YMj3iocryA)

# ì½”ë“œ

```c
#include <msp430.h> 

unsigned int global_count = 0;
int mode_select = 2; // 0 : left right alter , 1 : left right blink sametime , 2 : Terminate
int led_state = 0; // 0 : off, 1 : on
int right_led_state = 0; // 0 : off, 1 : on

/**
 * main.c
 */
int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer

    P1DIR |= BIT0; // left LED dir
    P4DIR |= BIT7; // right LED dir

    P1OUT &= ~BIT0; // left LED off

    P4OUT &= ~BIT7; // right LED off

    P2OUT |= BIT1; // left switch dir
    P2REN |= BIT1; // left switch pullup

    P1OUT |= BIT1; // right switch dir;
    P1REN |= BIT1; // right switch pullup;

    TA0CTL = TASSEL_2 + MC_1 + TACLR; // SMCLK : 1Mhz, Up mode to CCR0
    TA0CCTL0 = CCIE;
    TA0CCR0 = 1000; // 1ms = 1000 * 1s

    // Right switch Interrupt
    P1IE |= BIT1; // Interrupt enable
    P1IES |= BIT1; // Interrupt edge(Falling Edge)
    P1IFG &= ~BIT1; // Interrupt Flag

    // Left switch Interrupt
    P2IE |= BIT1; // Interrupt enable
    P2IES |= BIT1; // Interrupt edge(Falling Edge)
    P2IFG &= ~BIT1; // Interrupt Flag

    __bis_SR_register(GIE);

    while(1)
    {
        if(global_count>=1000){
            if(mode_select == 0){
                if(led_state == 0){
                    P1OUT ^= BIT0;
                    P4OUT |= BIT7;
                    led_state = 1;
                }else{
                    P4OUT ^= BIT7;
                    P1OUT |= BIT0;
                    led_state = 0;
                }
                global_count = 0; // ì¹´ìš´í„° ì´ˆê¸°í™”
            }
            if(mode_select == 1){
                if(led_state == 0){
                    P1OUT |= BIT0; // left LED ì¼œê¸°
                    P4OUT |= BIT7; // right LED ì¼œê¸°
                    led_state = 1;
                }else{
                    P1OUT &= ~BIT0; // left LED ë„ê¸°
                    P4OUT &= ~BIT7; // right LED ë„ê¸°
                    led_state = 0;
                }

                global_count = 0; // ì¹´ìš´í„° ì´ˆê¸°í™”
            }
        }
        if(mode_select == 2){
            P1OUT &= ~BIT0; // left LED ë„ê¸°
            P4OUT &= ~BIT7; // right LED ë„ê¸°
        }
    }
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
    global_count++;
}

#pragma vector = PORT1_VECTOR
__interrupt void Port_1(void)
{
    if(mode_select != 0){
        mode_select = 0; // left right alter mode
    }else{
        mode_select = 2;
    }

    P1IFG &= ~BIT1; // IFG is cleared

}

#pragma vector = PORT2_VECTOR
__interrupt void Port_2(void)
{
    if(mode_select != 1){
        mode_select = 1; // left right alter mode
    }else{
        mode_select = 2;
    }
    P2IFG &= ~BIT1; // IFG is cleared
}

```

ì´ìƒì…ë‹ˆë‹¤.