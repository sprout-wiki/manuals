
로터리 엔코더 : 모터에 부착, 회전할때마다 신호발생
증분형 엔코더 : 모터가 회전한 각도에 비례하는 펄스 출력

MSP430 실습보드 엔코더 : 335펄스, 한바퀴 약 1340 카운트 가능

실습1 : 바퀴를 움직이면서 엔코더 값을 확인
```c
#include <msp430.h>

unsigned int digits[10] = { 0xdb, 0x50, 0x1f, 0x5d, 0xd4, 0xcd, 0xcf, 0xd8, 0xdf, 0xdd };
int encoder_cnt = 0;
unsigned int cnt = 0;

void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;
    /* Digital Output - 7 segment */

    P3DIR |= 0xffff;
    P3OUT &= 0x0000;
    P4DIR |= 0x000f;
    P4OUT &= ~BIT0;

	// interrupt set
	P1IE |= BIT5; // Interrupt enabled
	P1IES |= BIT5; // Falling Edge
	P1IFG &= BIT4; // Interrupt flag
	
	P1IE |= BIT4; //Interrupt enabled
	P1IES |= BIT4; // Falling Edge
	P1IFG &= ~BIT4; // Interrupt flag

    __bis_SR_register(GIE);

    while(1)
    {
        P3OUT = digits[encoder_cnt%10];
        P4OUT = ~BIT0;
        __delay_cycles(5000);
        
        P3OUT = digits[encoder_cnt/10%10];
        P4OUT = ~BIT1;
        __delay_cycles(5000);

		P3OUT = digits[encoder_cnt/100%10];
        P4OUT = ~BIT2;
        __delay_cycles(5000);

		P3OUT = digits[encoder_cnt/1000%10];
        P4OUT = ~BIT3;
        __delay_cycles(5000);
    }
}

#pragma vector = PORT1_VECTOR
__interrupt void Port_1(void)
{
	if(P1IFG & BIT3)
	{
		if(P1IN & BIT2) != 0)
		{
			encoder_cnt --;
		}
		else
		{
			encoder_cnt ++;
		}
	}
	if(P1IFG & BIT2)
	{
		if((P1IN & BIT3)==0)
		{
			encoder_cnt--;
		}	
		else
		{
			encoder_cnt++;
		}
	}
	if(encoder_cnt > 9999)
		encoder_cnt = 0;
	else if(encoder_cnt < 0)
		encoder_cnt = 9999;
		
	P1IFG &= ~BIT3;
	P1IFG &= ~BIT2;
}
```

작동확인된 코드
```c
#include <msp430.h>

unsigned int digits[10] = { 0xdb, 0x50, 0x1f, 0x5d, 0xd4, 0xcd, 0xcf, 0xd8, 0xdf, 0xdd };
int encoder_cnt = 0;

void main(void) {
    WDTCTL = WDTPW | WDTHOLD; // stop watchdog timer

    // Digital Output - 7 segment
    P3DIR |= 0xffff;
    P3OUT &= 0x0000;
    P4DIR |= 0x000f;
    P4OUT &= ~BIT0;

    // interrupt set
    P1DIR &= ~(BIT3 | BIT2); // Set P1.2 and P1.3 as input
    P1IE |= BIT3 | BIT2; // Interrupt enabled for P1.2 and P1.3
    P1IES |= BIT3 | BIT2; // Interrupt edge (Falling Edge)
    P1IFG &= ~(BIT3 | BIT2); // Clear interrupt flags for P1.2 and P1.3

    __bis_SR_register(GIE); // Enable interrupts

    while (1) {
        P3OUT = digits[encoder_cnt % 10];
        P4OUT = ~BIT0;
        __delay_cycles(5000);

        P3OUT = digits[(encoder_cnt / 10) % 10];
        P4OUT = ~BIT1;
        __delay_cycles(5000);

        P3OUT = digits[(encoder_cnt / 100) % 10];
        P4OUT = ~BIT2;
        __delay_cycles(5000);

        P3OUT = digits[(encoder_cnt / 1000) % 10];
        P4OUT = ~BIT3;
        __delay_cycles(5000);
    }
}

#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void) {
    if (P1IFG & BIT3) {
        if ((P1IN & BIT2) != 0) {
            encoder_cnt--;
        } else {
            encoder_cnt++;
        }
        P1IFG &= ~BIT3; // Clear interrupt flag for P1.3
    }
    if (P1IFG & BIT2) {
        if ((P1IN & BIT3) == 0) {
            encoder_cnt--;
        } else {
            encoder_cnt++;
        }
        P1IFG &= ~BIT2; // Clear interrupt flag for P1.2
    }
    if (encoder_cnt > 9999) {
        encoder_cnt = 0;
    } else if (encoder_cnt < 0) {
        encoder_cnt = 9999;
    }
}

```